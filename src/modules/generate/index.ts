import { randomUUID } from "node:crypto";
import { promises as fs } from "fs";
import path from "path";
import { Prisma } from "@prisma/client";
import { prisma } from "../../config/db";
import { logger } from "../../config/logger";
import { generateText } from "../../lib/ai";
import {
  ensureDir,
  resolveGeneratedPath,
  writeJsonFile,
} from "../../lib/storage";

interface GenerateContext {
  jobId: string;
  metadata?: Record<string, unknown>;
}

const slugify = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "")
    .slice(0, 40);

const toJson = (value: unknown): Prisma.InputJsonValue =>
  value as Prisma.InputJsonValue;

const buildPreviewSvg = (title: string) => `<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#9333ea" />
      <stop offset="100%" stop-color="#f97316" />
    </linearGradient>
  </defs>
  <rect width="800" height="600" fill="url(#gradient)" rx="32" />
  <text x="50%" y="45%" text-anchor="middle" font-family="Arial" font-size="48" fill="#ffffff">${title}</text>
  <text x="50%" y="60%" text-anchor="middle" font-family="Arial" font-size="24" fill="#f9fafb">Generated by etsy-gen</text>
</svg>`;

export const runGenerateStage = async ({ jobId }: GenerateContext) => {
  const trends = await prisma.trend.findMany({
    orderBy: { score: "desc" },
    take: 3,
  });

  if (trends.length === 0) {
    logger.warn("No trends available; using fallback content");
  }

  const targets = trends.length ? trends : [
    {
      niche: "Printable Wall Art",
      score: 0.7,
      summary: "Fallback niche for digital art prints.",
      recommendedAssets: [],
    },
  ];

  const products = [];

  for (const trend of targets) {
    const id = `prod_${randomUUID()}`;
    const title = `${trend.niche} Digital Bundle`;
    const prompt = `
Niche: ${trend.niche}
Trend summary: ${"summary" in trend ? trend.summary ?? "" : ""}
Score: ${trend.score}

Propose a short marketing description (<=120 words) and 8 SEO tags for a digital product bundle.
`;
    const generation = await generateText(prompt);

    const tags = generation.text
      .split(/[,#]/)
      .map((tag) => tag.trim().toLowerCase())
      .filter((tag) => tag.length > 2)
      .slice(0, 8);

    const productDir = resolveGeneratedPath(id);
    await ensureDir(productDir);

    const metadata = {
      id,
      title,
      trend: trend.niche,
      createdAt: new Date().toISOString(),
      description: generation.text.trim(),
      tags,
    };

    const previewPath = path.join(productDir, "preview.svg");
    const descriptionPath = path.join(productDir, "description.md");

    await fs.writeFile(previewPath, buildPreviewSvg(title), "utf8");
    await fs.writeFile(
      descriptionPath,
      `# ${title}\n\n${generation.text.trim()}\n`,
      "utf8",
    );
    await writeJsonFile(path.join(productDir, "metadata.json"), metadata);

    const relativePreview = path.relative(process.cwd(), previewPath);
    const relativeDescription = path.relative(process.cwd(), descriptionPath);

    const product = await prisma.product.upsert({
      where: { id },
      update: {
        title,
        description: generation.text.trim(),
        tags,
        attributes: toJson({ niche: trend.niche }),
        assetPaths: [relativePreview, relativeDescription],
        previewUrl: relativePreview,
        metadata: toJson({ trend }),
        jobId,
      },
      create: {
        id,
        title,
        description: generation.text.trim(),
        tags,
        attributes: toJson({ niche: trend.niche }),
        assetPaths: [relativePreview, relativeDescription],
        previewUrl: relativePreview,
        metadata: toJson({ trend }),
        jobId,
      },
    });

    products.push(product);
  }

  logger.info({ generated: products.length }, "Generate stage completed");

  return {
    summary: {
      generated: products.length,
    },
  };
};
